## 1주차


#### 개념 - 갯수 세기
갯수를 세는 문제는 map 또는 배열을 이용하여 풀이한다.
key가 int, char기반일 때는 주로 배열을, sparse한 int나 string 기반일 때는 map을 주로 쓴다.
map의 선언과, 순회를 통한 값 확인 방법은 다음과 같다.
```c
// map 선언
map<string, string> m;
m["seoul"] = "02";

// map 순회
for (auto iter : m) {
  cout << iter.first << "의 지역번호:" << iter.second << endl;
}
```

#### 개념 - 누적합(Prefix sum)
누적합은 문제에서 수열이 주어지고 어떤 구간의 값의 합을 구해야 할 때 쓰인다. 

예를들어 배열에서 a번 index와 b번 index 사이구간의 구간합을 구한다고 가정하면, 
누적합은 arr\[0\~b까지의 누적합] - arr[0~a-1까지의누적합]으로 표현할 수 있다.

<br/>

#### 문제 - 3986 좋은 단어
풀이 방법이 생각이 나지 않을 땐 **도식화를 시도** 해야한다.
문자열을 활용하는 문제에서는 **문자열을 뒤집어 보거나, 하나를 더 붙여보거나, 90도 회전을 시켜 보며 방법을 생각 해 볼 수 있다**.
해당 문제의 같은 경우에도 문자열을 90도 회전 시켜보면 stack을 활용할 수 있음이 보인다.
<img width="360" alt="image" src="https://user-images.githubusercontent.com/76279010/221346489-b324eeed-ee61-4375-82b1-cb6012629a50.png">

들어오는 수가 stack의 top 요소와 같으면 pop하여 문제를 해결한다.

#### 문제 - 1629 곱셈
2^4 = 2^2 x 2^2
2^8 = 2^4 x 2^4 
형태의 반복이므로, 한 번의 계산에서 완성된 변수를 계속 저장해서 재활용한다는 생각으로 **재귀를 사용해서 시간 복잡도를 줄일 수 있다.**

그리고 자주 사용하는 **정수론 개념**도 암기할 필요가 있다.

(a+b)%c = (a%c) + (b%c)

(a*b)%c = (a%c) * (b%c)


#### 문제 - 4375 1
알고리즘 문제 풀이의 루틴은 **최대 최소 범위 확인 -> 무식하게 풀 수 있는지를 먼저 확인**해야 한다.
해당 문제의 경우 먼저 1로 구성된 숫자를 만들고 배수인지를 확인하면 overflow가 발생한다.
앞서 말한 정수론의 개념과 111은 100 + 10 + 1과 같음을 이용하여 문제를 풀이한다.